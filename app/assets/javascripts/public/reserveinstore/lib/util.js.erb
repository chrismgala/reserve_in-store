ReserveInStore.Util = {
    /**
     * Tells you if the element selector is visible in any way in view.
     * @param $el jquery element selector
     * @returns {boolean} True if it is, false otherwise
     */
    isFullyVisible: function($el) {
        if ($el.data('always_visible')) {
            return true;
        }

        var usingJquery = (Object && Object.getPrototypeOf) ? Object.getPrototypeOf($el).jquery : ($ && $.zepto);

        if (usingJquery) {
            if (!$el.is(':visible')) {
                return false;
            }
        }

        if (!this.isScrolledIntoView($el)) {
            return false;
        }
        if ($el.css('display') == 'none' || $el.css('visibility') == 'hidden' || $el.css('opacity') == 0) {
            return false;
        }

        var $parent = $el.parent();
        while ($parent.prop("tagName") !== 'BODY') {
            if ($parent.css('visibility') == 'hidden' || $parent.css('opacity') == 0) {
                return false;
            }
            $parent = $parent.parent();
        }

        return true;
    },

    /**
     *
     * @param $form
     */
    serializeObject: function ($form) {
        var $ = this.$(),
            json = {},
            push_counters = {},
            patterns = {
                "validate": /^[a-zA-Z][a-zA-Z0-9_]*(?:\[(?:\d*|[a-zA-Z0-9_]+)\])*$/,
                "key": /[a-zA-Z0-9_]+|(?=\[\])/g,
                "push": /^$/,
                "fixed": /^\d+$/,
                "named": /^[a-zA-Z0-9_]+$/
            };


        var build = function(base, key, value) {
            base[key] = value;
            return base;
        };

        var pushCounter = function(key) {
            if (push_counters[key] === undefined) {
                push_counters[key] = 0;
            }
            return push_counters[key]++;
        };

        $.each($form.serializeArray(), function() {

            // skip invalid keys
            if (!patterns.validate.test(this.name)) {
                return;
            }

            var k,
                keys = this.name.match(patterns.key),
                merge = this.value,
                reverse_key = this.name;

            while ((k = keys.pop()) !== undefined) {

                // adjust reverse_key
                reverse_key = reverse_key.replace(new RegExp("\\[" + k + "\\]$"), '');

                // push
                if (k.match(patterns.push)) {
                    merge = build([], pushCounter(reverse_key), merge);
                }

                // fixed
                else if (k.match(patterns.fixed)) {
                    merge = build([], k, merge);
                }

                // named
                else if (k.match(patterns.named)) {
                    merge = build({}, k, merge);
                }
            }

            json = $.extend(true, json, merge);
        });

        return json;
  },

    /**
     * Runs the callback with the result of whether the browser's incogneto mode is enabled
     * @param {function} callback - callback(true) if incogneto mode is enabled, callback(false) otherwise.
     * @deprecated We don't use this right now but leaving the code here in case we want to use it in the future.
     */
    // checkIncognetoMode: function (callback) {
    //     var fs = window.RequestFileSystem || window.webkitRequestFileSystem;
    //     if (!fs) {
    //         return callback(false);
    //     }
    //     fs(window.TEMPORARY, 100, function (fs) {
    //         return callback(false);
    //     }, function (err) {
    //         return callback(true);
    //     });
    // },

    /**
     * @param {Selector} $el
     * @returns {string}
     */
    outerHeight: function($el) {
        var elmHeight, elmMargin, elm = $el.get(0);
        if (document.all) {// IE
            elmHeight = elm.currentStyle.height;
            elmMargin = parseInt(elm.currentStyle.marginTop, 10) + parseInt(elm.currentStyle.marginBottom, 10) + "px";
        } else {// Mozilla
            elmHeight = document.defaultView.getComputedStyle(elm, '').getPropertyValue('height');
            elmMargin = parseInt(document.defaultView.getComputedStyle(elm, '').getPropertyValue('margin-top')) + parseInt(document.defaultView.getComputedStyle(elm, '').getPropertyValue('margin-bottom')) + "px";
        }
        return (elmHeight + elmMargin);
    },

    /**
     * Lets you update a URL param regardless of whether or not it is there currently or not
     * @param url {string} - URL you want to modify
     * @param param {string} - The name of the param to look for in the URL
     * @param paramVal (string) - Value of the param that you want
     * @returns {string} - The URL with the param updated
     */
    updateURLParameter: function(url, param, paramVal) {
        var newAdditionalURL = "";
        var tempArray = url.split("?");
        var baseURL = tempArray[0];
        var additionalURL = tempArray[1];
        var temp = "";
        if (additionalURL) {
            tempArray = additionalURL.split("&");
            for (var i = 0; i < tempArray.length; i++) {
                if (tempArray[i].split('=')[0] != param) {
                    newAdditionalURL += temp + tempArray[i];
                    temp = "&";
                }
            }
        }

        var newUrl = baseURL + "?" + newAdditionalURL;

        if (paramVal !== null) {
            newUrl += temp + param + "=" + paramVal;
        }

        if (newUrl === baseURL + '?') return baseURL;

        return newUrl;
    },


    /**
     * Opposite of #isFullyVisible()
     * @param $el jquery element selector
     * @returns {boolean} True if the element selector is NOT visible in any way in view.
     */
    isFullyInvisible: function($el) {
        return !this.isFullyVisible($el);
    },

    /**
     * Tells you if an element is scrolled into the current viewport
     * @param $el jquery element selector
     * @returns {boolean} True if it is, false otherwise
     */
    isScrolledIntoView: function($el) {
        var docViewTop = this.$()(window).scrollTop();
        var docViewBottom = docViewTop + this.$()(window).height();

        var elemTop = $el.offset().top;
        var elemBottom = elemTop + $el.height();

        return ((elemBottom <= docViewBottom) && (elemTop >= docViewTop));
    },

    /**
     * @param $el - Show the element and strip any transform css. This is necessary due to the zepto fx_methods library causing us headaches with position styles.
     */
    showWithoutTransform: function($el) {
        $el.show().css({
            '-webkit-transform': '',
            '-moz-transform': '',
            '-ms-transform': '',
            '-o-transform': '',
            'transform': '',
        });
    },

    /**
     * Adds the Zepto library to the current document body
     */
    addZepto: function(opts, callback) {
        callback = callback || function() {
        };
        var asset = new ReserveInStoreCachedAsset({
            name: 'zepto',
            version: '1.2.0',
            expiresIn: opts.devMode ? 15 : (15 * 60), // Expires in 15 minutes in production, or 15 seconds in dev mode.
            url: "https://cdn.fera.ai/js/lib/zepto" + (opts.debugMode ? '' : '.min') + ".js"
        });
        asset.load(callback);
    },

    /**
     * @returns {*} jQuery or Zepto depending on what's available
     */
    $: function() {
        if (typeof jQuery !== 'undefined') return jQuery;
        if (typeof $ !== 'undefined' && typeof $.fn !== 'undefined' && typeof $.fn.jquery !== 'undefined') return $;
        if (typeof Zepto !== 'undefined') return Zepto;
        return Zepto;
    },

    /**
     * @param str {string} String to capitalize the first letter of
     * @returns {string} joe => Joe
     */
    capitalizeFirstLetter: function(str) {
        return str.charAt(0).toUpperCase() + str.slice(1);
    },

    /**
     * Shuffles array in place.
     * @param a {Array} a items An array containing the items.
     */
    shuffleArray: function(a) {
        var j, x, i;
        for (i = a.length - 1; i > 0; i--) {
            j = Math.floor(Math.random() * (i + 1));
            x = a[i];
            a[i] = a[j];
            a[j] = x;
        }
        return a;
    },

    waitFor$: function(callback, opts) {
        var waitSoFar = 0, checkInterval = 10, warningThreshold = 100, loadingZepto = false;
        opts = opts || {};

        // If we're in standalone mode then don't wait for jQuery to load slowly, just load our own immediately if one is not already present.
        // This is useful in scenarios where loading high-speed is paramount (like the checkout), and can be used if we already
        // know that jQuery or Zepto are not going to be pre-loaded.
        if (opts.standaloneMode) {
            this.addZepto(opts);
            loadingZepto = true;
            warningThreshold += 1000; // Give us some time to load Zepto if it needs to be loaded
            checkInterval = 1; // Speed up the check interval
        } else {
            if (window.jQuery || window.Zepto || window.$) return callback();
        }

        if (opts.logger) logger.log("Waiting for jQuery or Zepto to load...");

        var self = this;

        var jqTimer = setInterval(function() {
            if (window.jQuery || window.Zepto || window.$) {
                clearInterval(jqTimer);
                callback();
            }
            waitSoFar += checkInterval;

            if (waitSoFar === warningThreshold) {
                if (!loadingZepto) {
                    warningThreshold += 1000; // Give it another 60 seconds to load zepto from the CDN
                    self.addZepto(opts);
                    loadingZepto = true;
                    if (opts.logger) logger.log("Loading Zepto library because jQuery was not found within " + warningThreshold + " milliseconds.");
                } else {
                    clearInterval(jqTimer);
                    throw "jQuery or Zepto are required and neither were found or able to be dynamically loaded.";
                }
            }
        }, checkInterval);
    },

    /**
     * Returns true is value is null or empty
     * @param value {*}
     */
    isNullOrEmpty: function(value) {
        return (!value || value === undefined || value === "" || value.length === 0);
    },

    /**
     * Returns the browser and browser version. For example: MSIE 8
     * @returns {string}
     */
    detectBrowser: function() {
        var ua = navigator.userAgent, tem,
            M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];
        if (/trident/i.test(M[1])) {
            tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
            return 'IE ' + (tem[1] || '');
        }
        if (M[1] === 'Chrome') {
            tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
            if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
        }
        M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
        if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
        return M.join(' ');
    },

    /**
     * @returns {boolean} True if the current browser is running microsoft internet explorer
     */
    ie: function() {
        return this.detectBrowser().indexOf("IE") === 0 || this.detectBrowser().indexOf("MSIE") !== -1;
    },

    /*
     * Used to limit GET requests
     * @see https://stackoverflow.com/questions/2400935/browser-detection-in-javascript#comment24686185_2401861
     * @return {number} Max characters we can use in a GET request
     */
    maxGetRequestChars: function() {
        if (this.detectBrowser().indexOf('MSIE') !== -1) return 2000;
        return 6000;
    },

    /**
     * Tells you how big some params are as a string.
     * @param params {object} - params you want to send via ajax to a server
     * @returns {number} - number of bytes in length that the params will be when converted to a string
     */
    sizeOfParams: function(params) {
        return encodeURI(this.$().param(params)).split(/%..|./).length - 1;
    },

    /**
     *  Base64 encode / decode
     *  http://www.webtoolkit.info
     */

    // private property
    _keyStr: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",

    // public method for encoding
    encode: function(input) {
        var output = "";
        var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
        var i = 0;

        input = this._utf8_encode(input);

        while (i < input.length) {

            chr1 = input.charCodeAt(i++);
            chr2 = input.charCodeAt(i++);
            chr3 = input.charCodeAt(i++);

            enc1 = chr1 >> 2;
            enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
            enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
            enc4 = chr3 & 63;

            if (isNaN(chr2)) {
                enc3 = enc4 = 64;
            } else if (isNaN(chr3)) {
                enc4 = 64;
            }

            output = output +
                this._keyStr.charAt(enc1) + this._keyStr.charAt(enc2) +
                this._keyStr.charAt(enc3) + this._keyStr.charAt(enc4);

        }

        return output;
    },

    // public method for decoding
    decode: function(input) {
        var output = "";
        var chr1, chr2, chr3;
        var enc1, enc2, enc3, enc4;
        var i = 0;

        input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

        while (i < input.length) {

            enc1 = this._keyStr.indexOf(input.charAt(i++));
            enc2 = this._keyStr.indexOf(input.charAt(i++));
            enc3 = this._keyStr.indexOf(input.charAt(i++));
            enc4 = this._keyStr.indexOf(input.charAt(i++));

            chr1 = (enc1 << 2) | (enc2 >> 4);
            chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
            chr3 = ((enc3 & 3) << 6) | enc4;

            output = output + String.fromCharCode(chr1);

            if (enc3 != 64) {
                output = output + String.fromCharCode(chr2);
            }
            if (enc4 != 64) {
                output = output + String.fromCharCode(chr3);
            }

        }

        output = this._utf8_decode(output);

        return output;

    },

    // private method for UTF-8 encoding
    _utf8_encode: function(string) {
        string = string.replace(/\r\n/g, "\n");
        var utftext = "";

        for (var n = 0; n < string.length; n++) {

            var c = string.charCodeAt(n);

            if (c < 128) {
                utftext += String.fromCharCode(c);
            }
            else if ((c > 127) && (c < 2048)) {
                utftext += String.fromCharCode((c >> 6) | 192);
                utftext += String.fromCharCode((c & 63) | 128);
            }
            else {
                utftext += String.fromCharCode((c >> 12) | 224);
                utftext += String.fromCharCode(((c >> 6) & 63) | 128);
                utftext += String.fromCharCode((c & 63) | 128);
            }

        }

        return utftext;
    },

    // private method for UTF-8 decoding
    _utf8_decode: function(utftext) {
        var string = "";
        var i = 0;
        var c = c1 = c2 = 0;

        while (i < utftext.length) {

            c = utftext.charCodeAt(i);

            if (c < 128) {
                string += String.fromCharCode(c);
                i++;
            }
            else if ((c > 191) && (c < 224)) {
                c2 = utftext.charCodeAt(i + 1);
                string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
                i += 2;
            }
            else {
                c2 = utftext.charCodeAt(i + 1);
                c3 = utftext.charCodeAt(i + 2);
                string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
                i += 3;
            }

        }

        return string;
    },

    jsonHasArray: function(json) {
        for (var key in json) {
            if (json[key] && typeof(json[key]) === "object" && json[key].constructor === Array) {
                return true;
            }
        }
        return false;
    },

    httpMethodToUse: function(eventParams) {
        //post if we have a shallow array since we can properly encode it that way
        var shouldPost = this.sizeOfParams(eventParams) > this.maxGetRequestChars() || this.jsonHasArray(eventParams);
        return shouldPost ? 'POST' : 'GET';
    }

};
